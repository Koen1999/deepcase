import copy
import numpy  as np
import pandas as pd
from collections import Counter
from tqdm        import tqdm

from state_machine import RuleSequence

class RuleEngine(object):

    def __init__(self):
        """Match traffic against known rules."""
        # Initialise internal rules
        self.rules       = dict()
        self.event_rules = dict()
        self.states      = dict()

    ########################################################################
    #                       Fit and predict methods                        #
    ########################################################################

    def fit(self, rules):
        """Fit engine with rules.

            Parameters
            ----------
            rules : list of dict()
                List of rules containing 'events' that specify relevant events.

            Returns
            -------
            self : self
                Returns self.
            """
        # Store all rules
        self.rules  = rules
        self.states = dict()

        # Loop over rule categories
        for category in rules:
            # Loop over directives
            for directive in category['directives']:
                # Add rule sequence
                self.states[directive['id']] = RuleSequence(directive['rules'])

        # Return self
        return self

        # Return self
        return self


    def predict(self, events, column='threat_name', time='ts_start', groupby=['source', 'src_ip'], verbose=False):
        """Predict events based on rules.

            Parameters
            ----------
            events : pd.DataFrame
                DataFrame of events. Should contain following columns:
                - column    of time parameter
                - column(s) of groupby parameter

            column : string, default='threat_name'
                Column from which to extract event.
                Default is events for Company dataset.

            time : string, default='ts_start'
                Column to sort by.
                Default is time for Company dataset.

            groupby : list, default=['source', 'src_ip']
                List of columns to group by.
                Default is machine for Company dataset.

            verbose : boolean, default=False
                If True, print progress.

            Returns
            -------
            result : np.array of shape=(n_samples,)
                Array of matching rule IDs or -1 if no rule could be matched.
            """
        # Initialise result
        result = np.full(events.shape[0], -1)
        all_alerts = dict()

        # Sort events - default by time
        events = events.sort_values(by=time)
        # Group events - default by machine
        grouped_events = events.groupby(groupby)

        # Add verbose if necessary
        if verbose: grouped_events = tqdm(grouped_events, desc='Matching')

        # Loop over each group (machine) and get generated events
        for machine, events_ in grouped_events:

            # Copy all states
            states = copy.deepcopy(self.states)

            # Initialise alerts generated by machine
            alerts  = dict()

            # Loop over events
            for index, event, timestamp in zip(events_.index, events_[column], events_[time]):

                # Keep an index of all matches
                matches = dict()

                # Loop over all states
                for identifier, state in states.items():
                    # Ensure state is RuleSequence
                    assert isinstance(state, RuleSequence)

                    # Check if there is a next state
                    match, next_state = state.transition(event, timestamp)

                    # Reset timeout states
                    if str(next_state.identifier).endswith('_timeout'):
                        # Reset state
                        states[identifier].reset()

                    # Add match if applicable
                    if match: matches[identifier] = next_state



                # Update all states
                for identifier, state in matches.items():
                    # Update state
                    states[identifier].current = state
                    # Add index to alert
                    if identifier not in alerts:
                        alerts[identifier] = list()
                    alerts[identifier].append(index)

                # Set result to 1 if necessary
                if matches: result[index] = 1

            # Clean alerts to largest
            alerts_  = dict()
            indices_ = set()
            for identifier, alert in sorted(alerts.items(), key=lambda x: len(x[1])):
                # Add alert
                alert_indices = set(alert) - indices_
                # Add indices
                indices_ |= set(alert)
                # Add indices if alert still exists
                if len(alert_indices) >= 1:
                    alerts_[identifier] = list(alert_indices)

            # Add alerts for machine
            all_alerts[machine] = alerts_

        # Return result
        return result, all_alerts


    ########################################################################
    #                            Retrieve rules                            #
    ########################################################################

    def get_rules(self, event):
        """Get all matching rules based on event.

            Parameters
            ----------
            event : int
                ID of event for which to retrieve rules.

            Returns
            -------
            rules : list()
                List of relevant rules.
            """
        return [
            self.rules[id]                               # Get matching rule
            for id in self.event_rules.get(event, set()) # Get matching rule IDs
        ]
