import numpy as np
from tqdm import tqdm

class SigmaEngine(object):

    def __init__(self):
        self.rules = dict()

    def fit(self, rules):
        """Fit engine with rules.

            Parameters
            ----------
            rules : list of dict()
                List of rules containing 'events' that specify relevant events.

            Returns
            -------
            self : self
                Returns self.
            """
        # Clear rules
        self.rules = dict()

        # Loop over rules
        for rule in rules:
            # Loop over directives
            for directive in rule['directives']:
                # Extract identifier
                identifier = directive['id']

                # Initialise rules for identifier
                assert identifier not in self.rules, "Identifier already exists"
                self.rules[identifier] = set()

                # Loop over subrules
                for subrule in directive['rules']:
                    # Extract events
                    events = set(subrule['events'].keys())

                    # Add to identifier
                    if not self.rules[identifier]:
                        self.rules[identifier] = events

                    # Assert events match existing events
                    assert events == self.rules[identifier], "Different rules"

        # Get efficient rule mapping
        self.rules_map = dict()
        for identifier, events in self.rules.items():
            for event in events:
                if event not in self.rules_map:
                    self.rules_map[event] = set()
                self.rules_map[event].add(identifier)

        # Return self
        return self


    def predict(self, events, column='threat_name', time='ts_start', groupby=['source', 'src_ip'], verbose=False):
        """Predict events based on rules.

            Parameters
            ----------
            events : pd.DataFrame
                DataFrame of events. Should contain following columns:
                - column    of time parameter
                - column(s) of groupby parameter

            column : string, default='threat_name'
                Column from which to extract event.
                Default is events for Company dataset.

            time : string, default='ts_start'
                Column to sort by.
                Default is time for Company dataset.

            groupby : list, default=['source', 'src_ip']
                List of columns to group by.
                Default is machine for Company dataset.

            verbose : boolean, default=False
                If True, print progress.

            Returns
            -------
            result : np.array of shape=(n_samples,)
                Array of matching rule IDs or -1 if no rule could be matched.
            """
        # Initialise result
        result = np.full(events.shape[0], -1)
        total_alerts = 0
        all_alerts   = dict()

        # Sort events - default by time
        events = events.sort_values(by=time)
        # Group events - default by machine
        grouped_events = events.groupby(groupby)

        # Add verbose if necessary
        if verbose: grouped_events = tqdm(grouped_events, desc='Matching')

        # Loop over each group (machine) and get generated events
        for machine, events_ in grouped_events:

            # Initialise alerts generated by machine
            alerts  = dict()

            # Loop over events
            for index, event, timestamp in zip(events_.index, events_[column], events_[time]):

                # Keep an index of all matches
                matches = self.rules_map.get(event, set())

                for match in matches:
                    if match not in alerts:
                        alerts[match] = 0
                    alerts[match] += 1

                # Set result if necessary
                if matches:
                    result[index] = total_alerts

            total_alerts += len(alerts)

            for identifier, count in alerts.items():
                if identifier not in all_alerts:
                    all_alerts[identifier] = 0
                all_alerts[identifier] += count

        if verbose:
            for alert, count in all_alerts.items():
                print(alert, count)
            print()

        # Return result
        return result, total_alerts
